# -*- coding: utf-8 -*-
"""notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/107BwfN3_41aRRepBqCAhOgOGGUGiiMna
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
# %matplotlib inline

"""## Data Loading"""

water_potability_df = pd.read_csv("data/water_potability.csv")
water_potability_df.head()

"""## Exploratory Data Analysis (EDA)

### Deskripsi Variabel

Deskripsi Variabel

Penjelasan setiap kolom
pH: Tingkat pH air.
Hardness: Kesadahan air, ukuran kandungan mineral.
Solids: Total padatan terlarut di dalam air.
Chloramines: Konsentrasi kloramin di dalam air.
Sulfate: Konsentrasi sulfat di dalam air.
Conductivity: Daya hantar listrik air.
Organic_carbon: Kandungan karbon organik dalam air.
Trihalomethanes: Konsentrasi trihalometana di dalam air.
Turbidity: Tingkat kekeruhan, ukuran kejernihan air.
Potability: Variabel target; menunjukkan potensi air dengan nilai 1 (dapat diminum) dan 0 (tidak dapat diminum).
"""

# Info Dataset
water_potability_df.info()

# Deskripsi Dataset
water_potability_df.describe()

"""### Menangani Missing Value"""

# Cek Missing Value
water_potability_df.isna().sum()

# Cek nilai NaN pada kolom "ph"
x = water_potability_df["ph"].isna().sum()

# Cek nilai NaN pada kolom "Sulfate"
y = water_potability_df["Sulfate"].isna().sum()

# Cek nilai NaN pada kolom "Trihalomethanes"
z = water_potability_df["Trihalomethanes"].isna().sum()

print("Nilai NaN di kolom Ph ada: ", x)
print("Nilai NaN di kolom Sulfate ada: ", y)
print("Nilai NaN di kolom Trihalomethanes ada: ", z)

water_potability_df.loc[(water_potability_df['Sulfate'].isna())]

# Cek apakah data bernilai NaN pada salah satu dimensi juga terdapat pada dimensi lain
is_in_all = water_potability_df["ph"].isna().isin(water_potability_df["Sulfate"].isna())

print(is_in_all)

# Mengganti nilai NaN pada kolom Sulfate dengan nilai rata-rata (Mean)
mean = water_potability_df["Sulfate"].mean()
water_potability_df["Sulfate"] = water_potability_df["Sulfate"].replace(np.nan, mean)
print(water_potability_df["Sulfate"].isna().sum())

# Mengganti nilai NaN pada kolom ph dengan nilai rata-rata (Mean)
mean = water_potability_df["ph"].mean()
water_potability_df["ph"] = water_potability_df["ph"].replace(np.nan, mean)
print(water_potability_df["ph"].isna().sum())

# Mengganti nilai NaN pada kolom ph dengan nilai rata-rata
mean = water_potability_df["Trihalomethanes"].mean()
water_potability_df["Trihalomethanes"] = water_potability_df["Trihalomethanes"].replace(np.nan, mean)
print(water_potability_df["Trihalomethanes"].isna().sum())

water_potability_df.describe()

# Cek Missing Value setelah di replace
water_potability_df.isna().sum()

water_potability_df.shape

"""### Menangani Outlier"""

# Outlier Fitur ph
sns.boxplot(x=water_potability_df['ph'])

# Outlier Fitur Hardness
sns.boxplot(x=water_potability_df['Hardness'])

# Outlier Fitur Solids
sns.boxplot(x=water_potability_df['Solids'])

# Outlier Fitur Chloramines
sns.boxplot(x=water_potability_df['Chloramines'])

# Outlier Fitur Sulfate
sns.boxplot(x=water_potability_df['Sulfate'])

# Outlier Fitur Conductivity
sns.boxplot(x=water_potability_df['Conductivity'])

# Outlier Fitur Organic_carbon
sns.boxplot(x=water_potability_df['Organic_carbon'])

# Outlier Fitur Trihalomethanes
sns.boxplot(x=water_potability_df['Trihalomethanes'])

# Outlier Fitur Turbidity
sns.boxplot(x=water_potability_df['Turbidity'])

# Solusi menyelesaikan Outliner

Q1 = water_potability_df.quantile(0.25)
Q3 = water_potability_df.quantile(0.75)
IQR=Q3-Q1
water_potability_df=water_potability_df[~((water_potability_df<(Q1-1.5*IQR))|(water_potability_df>(Q3+1.5*IQR))).any(axis=1)]

# Cek ukuran dataset setelah drop outliers
water_potability_df.shape

"""### Univariate Analysis"""

water_potability_df.hist(bins=50, figsize=(20, 15))
plt.show()

"""### Multivariate Analysis"""

sns.pairplot(water_potability_df, diag_kind = 'kde')

plt.figure(figsize=(10, 8))
correlation_matrix = water_potability_df.corr().round(2)

# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""## Data preparation

### Train Test Split
"""

from sklearn.model_selection import train_test_split

X = water_potability_df.drop(["Potability"],axis =1)
y = water_potability_df["Potability"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=123)

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""## Model Development"""

from sklearn.metrics import accuracy_score

models = pd.DataFrame(index=['train_accuracy', 'test_accuracy'],
                      columns=['LogisticRegression', 'KNN', 'RandomForest', 'NaiveBayes' ,'Boosting'])

"""### Logistic Regression"""

from sklearn.linear_model import LogisticRegression

logres = LogisticRegression()
logres.fit(X_train, y_train)

models.loc['train_accuracy', 'LogisticRegression'] = accuracy_score(y_true=y_train, y_pred=logres.predict(X_train))
models.loc['test_accuracy', 'LogisticRegression'] = accuracy_score(y_true=y_test, y_pred=logres.predict(X_test))

"""### KNN"""

from sklearn.neighbors import KNeighborsClassifier

knn = KNeighborsClassifier(n_neighbors=10)
knn.fit(X_train, y_train)

models.loc['train_accuracy', 'KNN'] = accuracy_score(y_true=y_train, y_pred=knn.predict(X_train))
models.loc['test_accuracy', 'KNN'] = accuracy_score(y_true=y_test, y_pred=knn.predict(X_test))

"""### Random Forest"""

from sklearn.ensemble import RandomForestClassifier

RF = RandomForestClassifier(n_estimators=50, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)

models.loc['train_accuracy', 'RandomForest'] = accuracy_score(y_true=y_train, y_pred=RF.predict(X_train))
models.loc['test_accuracy', 'RandomForest'] = accuracy_score(y_true=y_test, y_pred=RF.predict(X_test))

"""### Naive Bayes"""

from sklearn.naive_bayes import GaussianNB

NB = GaussianNB()
NB.fit(X_train, y_train)

models.loc['train_accuracy', 'NaiveBayes'] = accuracy_score(y_true=y_train, y_pred=NB.predict(X_train))
models.loc['test_accuracy', 'NaiveBayes'] = accuracy_score(y_true=y_test, y_pred=NB.predict(X_test))

"""### Boosting Algoritm"""

from sklearn.ensemble import AdaBoostClassifier

boosting = AdaBoostClassifier(learning_rate=0.05, random_state=55)
boosting.fit(X_train, y_train)
models.loc['train_accuracy', 'Boosting'] = accuracy_score(y_true=y_train, y_pred=boosting.predict(X_train))
models.loc['test_accuracy', 'Boosting'] = accuracy_score(y_true=y_test, y_pred=boosting.predict(X_test))

"""## Evaluasi Model"""

# Buat variabel akurasi yang isinya adalah dataframe nilai akurasi data train dan test pada masing-masing algoritma
akurasi = pd.DataFrame(columns=['train', 'test'], index=['Logre','KNN','RF','NaiveBayes','Boosting'])

# Buat dictionary untuk setiap algoritma yang digunakan
model_dict = {'Logre': logres,'KNN': knn, 'RF': RF, 'NaiveBayes': NB ,'Boosting': boosting}

# Hitung akurasi masing-masing algoritma pada data train dan test
for name, model in model_dict.items():
    akurasi.loc[name, 'train'] = accuracy_score(y_true=y_train, y_pred=model.predict(X_train))
    akurasi.loc[name, 'test'] = accuracy_score(y_true=y_test, y_pred=model.predict(X_test))

# Panggil akurasi
akurasi

fig, ax = plt.subplots()
akurasi.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

"""## Archieved

Melakukan beberapa tahap preparation tambahan PCA dan Standarisasi
(Masih dalam tahap uji coba)
"""

numerical_features = ['ph', 'Hardness', 'Solids', 'Chloramines', 'Sulfate', 'Conductivity', 'Organic_carbon', 'Trihalomethanes', 'Turbidity']

"""### PCA"""

from sklearn.decomposition import PCA

pca = PCA(n_components=9, random_state=123)
pca.fit(water_potability_df[numerical_features])
princ_comp = pca.transform(water_potability_df[numerical_features])

from sklearn.decomposition import PCA

pca = PCA(n_components=9, random_state=123)
pca.fit(water_potability_df[numerical_features])
princ_comp = pca.transform(water_potability_df[numerical_features])

pca.explained_variance_ratio_.round(4)

water_potability_df['dimension'] = pca.transform(water_potability_df.loc[:, ('ph', 'Hardness', 'Solids', 'Chloramines', 'Sulfate', 'Conductivity', 'Organic_carbon', 'Trihalomethanes', 'Turbidity')]).flatten()

"""### Menerapkan Standarisasi"""

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
scaler.fit(X_train[numerical_features])
X_train[numerical_features] = scaler.transform(X_train.loc[:, numerical_features])
X_train[numerical_features].head()

X_train[numerical_features].describe().round(4)

"""### Evaluasi Model"""

# KNN
knn = KNeighborsClassifier(n_neighbors=10)
knn.fit(X_train, y_train)
models.loc['train_accuracy', 'KNN'] = accuracy_score(y_true=y_train, y_pred=knn.predict(X_train))
models.loc['test_accuracy', 'KNN'] = accuracy_score(y_true=y_test, y_pred=knn.predict(X_test))

# Random Forest
RF = RandomForestClassifier(n_estimators=50, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)
models.loc['train_accuracy', 'RandomForest'] = accuracy_score(y_true=y_train, y_pred=RF.predict(X_train))
models.loc['test_accuracy', 'RandomForest'] = accuracy_score(y_true=y_test, y_pred=RF.predict(X_test))

# Boosting Algorithm
boosting = AdaBoostClassifier(learning_rate=0.05, random_state=55)
boosting.fit(X_train, y_train)
models.loc['train_accuracy', 'Boosting'] = accuracy_score(y_true=y_train, y_pred=boosting.predict(X_train))
models.loc['test_accuracy', 'Boosting'] = accuracy_score(y_true=y_test, y_pred=boosting.predict(X_test))

# Evaluasi Model
# Buat variabel akurasi yang isinya adalah dataframe nilai akurasi data train dan test pada masing-masing algoritma
akurasi = pd.DataFrame(columns=['train', 'test'], index=['KNN','RF','Boosting'])

# Buat dictionary untuk setiap algoritma yang digunakan
model_dict = {'KNN': knn, 'RF': RF, 'Boosting': boosting}

# Hitung akurasi masing-masing algoritma pada data train dan test
for name, model in model_dict.items():
    akurasi.loc[name, 'train'] = accuracy_score(y_true=y_train, y_pred=model.predict(X_train))
    akurasi.loc[name, 'test'] = accuracy_score(y_true=y_test, y_pred=model.predict(X_test))

# Panggil akurasi
akurasi